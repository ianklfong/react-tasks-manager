{"ast":null,"code":"import { createElement, cloneElement, Component } from 'react';\nimport Resizable from 're-resizable';\nimport isEqual from 'lodash.isequal';\nimport { Motion, spring } from 'react-motion';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport debounce from 'lodash.debounce';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = Object.setPrototypeOf || {\n  __proto__: []\n} instanceof Array && function (d, b) {\n  d.__proto__ = b;\n} || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = Object.assign || function __assign(t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nvar Pane =\n/** @class */\nfunction (_super) {\n  __extends(Pane, _super);\n\n  function Pane() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Pane.prototype.componentDidUpdate = function (prevProps) {\n    if (isEqual(prevProps.size, this.props.size)) return;\n    if (!this.props.onSizeChange) return;\n    this.props.onSizeChange();\n  };\n\n  Object.defineProperty(Pane.prototype, \"createAllowedProps\", {\n    get: function () {\n      var _this = this;\n\n      var props = {};\n      return Object.keys(this.props).reduce(function (acc, key) {\n        if (['resizable', 'onSizeChange'].indexOf(key) !== -1) return acc;\n        acc[key] = _this.props[key];\n        return acc;\n      }, props);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Pane.prototype.render = function () {\n    return createElement(Resizable, __assign({\n      enable: {\n        top: false,\n        right: this.props.resizable && this.props.resizable.x,\n        bottom: this.props.resizable && this.props.resizable.y,\n        left: false,\n        topRight: false,\n        bottomRight: this.props.resizable && this.props.resizable.xy,\n        bottomLeft: false,\n        topLeft: false\n      }\n    }, this.createAllowedProps), this.props.children);\n  };\n\n  Pane.defaultProps = {\n    minWidth: 0,\n    minHeight: 0,\n    maxWidth: undefined,\n    maxHeight: undefined,\n    style: {},\n    className: '',\n    grid: [1, 1],\n    resizable: {\n      x: true,\n      y: true,\n      xy: true\n    }\n  };\n  return Pane;\n}(Component);\n\nvar MAXIMUM_Z_INDEX = 2147483647;\nvar HYSTERESIS = 10;\n\nfunction reinsert(array, from, to) {\n  var a = array.slice(0);\n  var v = a[from];\n  a.splice(from, 1);\n  a.splice(to, 0, v);\n  return a;\n}\n\nvar directionDict = {\n  right: 'x',\n  bottom: 'y',\n  bottomRight: 'xy'\n};\n\nvar clamp = function (n, min, max) {\n  if (min === void 0) {\n    min = n;\n  }\n\n  if (max === void 0) {\n    max = n;\n  }\n\n  return Math.max(Math.min(n, max), min);\n};\n\nvar defaultSpringConfig = {\n  damping: 30,\n  stiffness: 500\n};\n\nvar SortablePane =\n/** @class */\nfunction (_super) {\n  __extends(SortablePane, _super);\n\n  function SortablePane(props) {\n    var _this = _super.call(this, props) || this;\n    /**\r\n     * Find the position sum of halfway points of panes surrounding a given pane\r\n     *\r\n     *  |-------------|\r\n     *  |             | ---> 'previous' halfway\r\n     *  |-------------|\r\n     *                  <--- margin\r\n     *  |-------------|\r\n     *  | currentPane |\r\n     *  |-------------|\r\n     *                  <--- margin\r\n     *  |-------------|\r\n     *  |             |\r\n     *  |             | ---> 'next' halfway\r\n     *  |             |\r\n     *  |-------------|\r\n     *\r\n     *\r\n     * @param  {number}   currentPane - Index of reference pane\r\n     * @param  {number[]} sizes       - Array of pane sizes\r\n     * @param  {number}   margin      - The margin between panes\r\n     * @return {object}               - Object containing 'previous' and 'next'\r\n     *                                  pane halfway points\r\n     */\n\n\n    _this.getSurroundingHalfSizes = function (currentPane, sizes, margin) {\n      var nextPane = currentPane + 1;\n      var prevPane = currentPane - 1;\n      return sizes.reduce(function (sums, size, index) {\n        var newSums = {\n          previous: 0,\n          next: 0\n        };\n\n        if (index < prevPane) {\n          newSums.previous = sums.previous + size + margin;\n        } else if (index === prevPane) {\n          newSums.previous = sums.previous + size / 2;\n        } else {\n          newSums.previous = sums.previous;\n        }\n\n        if (index < nextPane) {\n          newSums.next = sums.next + size + margin;\n        } else if (index === nextPane) {\n          newSums.next = sums.next + size / 2;\n        } else {\n          newSums.next = sums.next;\n        }\n\n        return newSums;\n      }, {\n        previous: 0,\n        next: 0\n      });\n    };\n\n    var order = props.order || props.defaultOrder;\n    var children = props.children || [];\n    _this.state = {\n      delta: 0,\n      mouse: 0,\n      isPressed: false,\n      lastPressed: 0,\n      isResizing: false,\n      panes: order ? order.map(function (key) {\n        var c = children.find(function (c) {\n          return c.key === key;\n        });\n\n        if (typeof c === 'undefined') {\n          throw new Error(\"key [\" + key + \"] is not found in props.children. Please set correct key name to Pane component.\");\n        }\n\n        return {\n          key: c.key,\n          ref: null\n        };\n      }) : children.map(function (child) {\n        return {\n          key: child.key,\n          ref: null\n        };\n      })\n    };\n    _this.sizePropsUpdated = false;\n    _this.handleTouchMove = _this.handleTouchMove.bind(_this);\n    _this.handleMouseUp = _this.handleMouseUp.bind(_this);\n    _this.handleMove = _this.handleMove.bind(_this);\n    _this.debounceUpdate = debounce(function () {\n      return _this.forceUpdate();\n    }, 100);\n    return _this;\n  }\n\n  SortablePane.prototype.componentDidMount = function () {\n    var _this = this;\n\n    if (typeof window !== 'undefined' && this.panesWrapper) {\n      var panesWrapper = this.panesWrapper;\n      panesWrapper.addEventListener('touchmove', this.handleTouchMove);\n      panesWrapper.addEventListener('touchend', this.handleMouseUp);\n      panesWrapper.addEventListener('mousemove', this.handleMove);\n      panesWrapper.addEventListener('mouseup', this.handleMouseUp);\n      panesWrapper.addEventListener('mouseleave', this.handleMouseUp);\n      this.resizeObserver = new ResizeObserver(this.debounceUpdate);\n    }\n\n    if (this.panesWrapper && this.panesWrapper.parentElement instanceof Element) {\n      this.resizeObserver.observe(this.panesWrapper);\n    }\n\n    if (!this.panesWrapper || !this.panesWrapper.children) return;\n    var panes = [].slice.apply(this.panesWrapper.children) || [];\n    var newPanes = this.panes.map(function (pane, i) {\n      return {\n        key: pane.key,\n        ref: panes[_this.order[i]]\n      };\n    });\n    this.setState({\n      panes: newPanes\n    });\n  };\n\n  SortablePane.prototype.componentDidUpdate = function (prevProps) {\n    var _this = this;\n\n    var panes = this.state.panes;\n    var children = this.props.children || [];\n    if (children.length > panes.length) return this.addPane();\n    if (children.length < panes.length) return this.removePane();\n\n    if (!isEqual(prevProps.order, this.props.order)) {\n      if (!this.panesWrapper) return;\n      var newPanes = (this.props.order || []).map(function (key) {\n        var index = [].slice.apply(_this.props.children).findIndex(function (c) {\n          return c.key === key;\n        });\n        return {\n          ref: _this.panesWrapper.children[index],\n          key: key\n        };\n      });\n      this.setState({\n        panes: newPanes\n      });\n    }\n\n    return undefined;\n  };\n\n  SortablePane.prototype.componentWillUnmount = function () {\n    if (typeof window !== 'undefined' && this.panesWrapper) {\n      var panesWrapper = this.panesWrapper;\n      panesWrapper.removeEventListener('touchmove', this.handleTouchMove);\n      panesWrapper.removeEventListener('touchend', this.handleMouseUp);\n      panesWrapper.removeEventListener('mousemove', this.handleMove);\n      panesWrapper.removeEventListener('mouseup', this.handleMouseUp);\n\n      if (this.panesWrapper && this.panesWrapper.parentElement instanceof Element) {\n        this.resizeObserver.unobserve(this.panesWrapper);\n      }\n    }\n  };\n\n  Object.defineProperty(SortablePane.prototype, \"order\", {\n    get: function () {\n      var children = this.props.children || [];\n\n      if (this.props.order) {\n        return this.props.order.map(function (key) {\n          return children.findIndex(function (c) {\n            return key === c.key;\n          });\n        });\n      }\n\n      return this.panes.map(function (p) {\n        return children.findIndex(function (c) {\n          return p.key === c.key;\n        });\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SortablePane.prototype, \"panes\", {\n    get: function () {\n      return this.state.panes.filter(function (p) {\n        return !!p;\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SortablePane.prototype.onResize = function (i, e, dir, elementRef, delta) {\n    var panes = this.state.panes;\n    this.forceUpdate();\n    var pane = panes[this.order.indexOf(i)];\n    if (!pane) return;\n    if (!this.props.onResize) return;\n    var direction;\n\n    if (dir === 'right' || dir === 'bottom' || dir === 'bottomRight') {\n      direction = directionDict[dir];\n    } else {\n      return;\n    }\n\n    this.props.onResize(e, pane.key, direction, elementRef, delta);\n  };\n\n  SortablePane.prototype.getPaneSizeList = function () {\n    var width = this.panes.map(function (pane) {\n      return Number(pane.ref && pane.ref.offsetWidth || 0);\n    });\n    var height = this.panes.map(function (pane) {\n      return Number(pane.ref && pane.ref.offsetHeight || 0);\n    });\n    return this.isHorizontal() ? width : height;\n  };\n  /**\r\n   * Determine where a particular pane should be ordered\r\n   *\r\n   * @param  {number} position     - Top of the current pane\r\n   * @param  {number} paneIndex    - Index of the pane\r\n   * @return {number}              - New index of the pane based on position\r\n   */\n\n\n  SortablePane.prototype.getItemCountByPosition = function (position, paneIndex) {\n    var size = this.getPaneSizeList();\n    var margin = this.props.margin;\n    var halfSizes = this.getSurroundingHalfSizes(paneIndex, size, margin || 0);\n    if (position + size[paneIndex] > halfSizes.next + HYSTERESIS) return paneIndex + 1;\n    if (position < halfSizes.previous - HYSTERESIS) return paneIndex - 1;\n    return paneIndex;\n  };\n\n  SortablePane.prototype.getItemPositionByIndex = function (index) {\n    var size = this.getPaneSizeList();\n    var sum = 0;\n    if (size.some(function (s) {\n      return typeof s === 'string';\n    })) return 0;\n\n    for (var i = 0; i < index; i += 1) {\n      sum += size[i] + (this.props.margin || 0);\n    }\n\n    return sum;\n  };\n\n  SortablePane.prototype.isHorizontal = function () {\n    return this.props.direction === 'horizontal';\n  };\n\n  SortablePane.prototype.addPane = function () {\n    var _this = this;\n\n    if (!this.panesWrapper || !this.panesWrapper.children) return;\n    var newPanes = this.panes;\n    var children = this.props.children || [];\n    children.forEach(function (child, i) {\n      var keys = _this.panes.map(function (pane) {\n        return pane.key;\n      });\n\n      if (keys.indexOf(child.key) === -1) {\n        var key = child.key;\n        var panesWrapper = _this.panesWrapper;\n        var pane = {\n          key: key,\n          ref: panesWrapper.children[i]\n        };\n        newPanes.splice(i, 0, pane);\n      }\n    });\n    this.setState({\n      panes: newPanes\n    });\n  };\n\n  SortablePane.prototype.removePane = function () {\n    var _this = this;\n\n    var newPanes = this.panes;\n    this.panes.forEach(function (pane, i) {\n      var keys = (_this.props.children || []).map(function (child) {\n        return child.key;\n      });\n\n      if (keys.indexOf(pane.key) === -1) {\n        newPanes.splice(i, 1);\n      }\n    });\n    this.setState({\n      panes: newPanes\n    });\n  };\n\n  SortablePane.prototype.handleResizeStart = function (i, e, dir) {\n    var panes = this.state.panes;\n    this.setState({\n      isResizing: true\n    });\n    var key = panes[this.order.indexOf(i)].key;\n    if (typeof key === 'undefined') return;\n\n    if (this.props.onResizeStart) {\n      var direction = void 0;\n\n      if (dir === 'right' || dir === 'bottom' || dir === 'bottomRight') {\n        direction = directionDict[dir];\n      } else {\n        return;\n      }\n\n      this.props.onResizeStart(e, key, direction);\n    }\n  };\n\n  SortablePane.prototype.handleResizeStop = function (i, e, dir, elementRef, delta) {\n    var panes = this.state.panes;\n    this.setState({\n      isResizing: false\n    });\n    var pane = panes[this.order.indexOf(i)];\n    var key = pane.key;\n    if (typeof key === 'undefined') return;\n\n    if (this.props.onResizeStop) {\n      var direction = void 0;\n\n      if (dir === 'right' || dir === 'bottom' || dir === 'bottomRight') {\n        direction = directionDict[dir];\n      } else {\n        return;\n      }\n\n      this.props.onResizeStop(e, key, direction, elementRef, delta);\n    }\n  };\n\n  SortablePane.prototype.handleMouseDown = function (pos, pressX, pressY, e) {\n    if (this.props.dragHandleClassName) {\n      if (e.target instanceof HTMLElement) {\n        if (!e.target.classList.contains(this.props.dragHandleClassName)) {\n          return;\n        }\n      }\n    }\n\n    var delta = 0;\n\n    if (window && window.TouchEvent && e.nativeEvent instanceof TouchEvent) {\n      var event_1 = e.nativeEvent.touches[0];\n      delta = this.isHorizontal() ? event_1.pageX - pressX : event_1.pageY - pressY;\n    } else if (MouseEvent && e.nativeEvent instanceof MouseEvent) {\n      var event_2 = e.nativeEvent;\n      delta = this.isHorizontal() ? event_2.pageX - pressX : event_2.pageY - pressY;\n    }\n\n    this.setState({\n      delta: delta,\n      mouse: this.isHorizontal() ? pressX : pressY,\n      isPressed: true,\n      lastPressed: pos\n    });\n    if (!this.props.children) return;\n    var child = this.props.children[pos];\n    if (!child) return;\n    if (child.props.onMouseDown) child.props.onMouseDown(e);\n\n    if (this.props.onDragStart) {\n      var c = this.panes.find(function (p) {\n        return p.key === child.key;\n      });\n\n      if (c && c.ref) {\n        this.props.onDragStart(e, child.key, c.ref);\n      }\n    }\n  };\n\n  SortablePane.prototype.handleMove = function (_a) {\n    var pageX = _a.pageX,\n        pageY = _a.pageY;\n    var _b = this.state,\n        isPressed = _b.isPressed,\n        delta = _b.delta,\n        lastPressed = _b.lastPressed,\n        isResizing = _b.isResizing,\n        panes = _b.panes;\n\n    if (isPressed && !isResizing) {\n      var mouse = this.isHorizontal() ? pageX - delta : pageY - delta;\n      var length_1 = (this.props.children || []).length;\n      var newPosition = this.getItemCountByPosition(mouse, this.order.indexOf(lastPressed));\n      var pos = clamp(Math.round(newPosition), 0, length_1 - 1);\n      var newPanes = reinsert(panes, this.order.indexOf(lastPressed), pos);\n      this.setState({\n        mouse: mouse,\n        panes: newPanes\n      });\n      if (!this.props.onOrderChange) return;\n\n      if (!isEqual(panes, newPanes)) {\n        if (this.props.onOrderChange) {\n          this.props.onOrderChange(newPanes.map(function (p) {\n            return String(p.key);\n          }));\n        }\n      }\n    }\n  };\n\n  SortablePane.prototype.handleTouchStart = function (key, x, y, e, child) {\n    if (child.props.onTouchStart) child.props.onTouchStart(e);\n    this.handleMouseDown(key, x, y, e);\n  };\n\n  SortablePane.prototype.handleTouchMove = function (e) {\n    e.preventDefault();\n    this.handleMove(e.touches[0]);\n  };\n\n  SortablePane.prototype.handleMouseUp = function (e) {\n    var children = this.props.children || [];\n    if (children.length === 0) return;\n    var wasPressed = this.state.isPressed;\n    this.setState({\n      isPressed: false,\n      delta: 0\n    });\n    var child = children[this.state.lastPressed];\n    var lastPressedId = child.key;\n    if (!this.props.isSortable) return;\n    var panes = this.state.panes;\n\n    if (this.props.onDragStop && wasPressed) {\n      var c = this.panes.find(function (p) {\n        return p.key === child.key;\n      });\n\n      if (c && c.ref) {\n        this.props.onDragStop(e, child.key, c.ref, panes.map(function (p) {\n          return String(p.key);\n        }));\n      }\n    }\n  };\n\n  SortablePane.prototype.renderPanes = function () {\n    var _this = this;\n\n    var _a = this.state,\n        mouse = _a.mouse,\n        isPressed = _a.isPressed,\n        lastPressed = _a.lastPressed,\n        isResizing = _a.isResizing;\n    var _b = this.props,\n        disableEffect = _b.disableEffect,\n        isSortable = _b.isSortable,\n        springConfig = _b.springConfig;\n    var children = this.props.children || [];\n    return children.map(function (child, i) {\n      var pos = _this.props.order ? _this.getItemPositionByIndex(_this.props.order.indexOf(String(child.key))) : _this.getItemPositionByIndex(_this.order.indexOf(i));\n      var springPosition = spring(pos, springConfig);\n      var style = lastPressed === i && isPressed && !isResizing ? {\n        scale: disableEffect ? 1 : spring(1.05, springConfig),\n        shadow: disableEffect ? 0 : spring(16, springConfig),\n        x: _this.isHorizontal() ? mouse : 0,\n        y: !_this.isHorizontal() ? mouse : 0\n      } : {\n        scale: disableEffect ? 1 : spring(1, springConfig),\n        shadow: disableEffect ? 0 : spring(0, springConfig),\n        x: _this.isHorizontal() ? springPosition : 0,\n        y: !_this.isHorizontal() ? springPosition : 0\n      };\n      return createElement(Motion, {\n        style: style,\n        key: String(child.key)\n      }, function (_a) {\n        var scale = _a.scale,\n            shadow = _a.shadow,\n            x = _a.x,\n            y = _a.y;\n\n        var onResize = _this.onResize.bind(_this, i);\n\n        var onMouseDown = isSortable ? _this.handleMouseDown.bind(_this, i, x, y) : function (e) {\n          if (child.props.onMouseDown) child.props.onMouseDown(e);\n        };\n\n        var onTouchStart = _this.handleTouchStart.bind(_this, i, x, y, child);\n\n        var onResizeStart = _this.handleResizeStart.bind(_this, i);\n\n        var onResizeStop = _this.handleResizeStop.bind(_this, i);\n\n        var onSizeChange = function () {\n          return _this.forceUpdate();\n        };\n\n        var style = __assign({}, child.props.style, {\n          boxShadow: \"rgba(0, 0, 0, 0.2) 0px \" + shadow + \"px \" + 2 * shadow + \"px 0px\",\n          transform: \"translate3d(\" + x + \"px, \" + y + \"px, 0px) scale(\" + scale + \")\",\n          WebkitTransform: \"translate3d(\" + x + \"px, \" + y + \"px, 0px) scale(\" + scale + \")\",\n          MozTransform: \"translate3d(\" + x + \"px, \" + y + \"px, 0px) scale(\" + scale + \")\",\n          MsTransform: \"translate3d(\" + x + \"px, \" + y + \"px, 0px) scale(\" + scale + \")\",\n          zIndex: i === lastPressed && _this.state.isPressed ? MAXIMUM_Z_INDEX : child.props.style && child.props.style.zIndex || 'auto',\n          position: 'absolute',\n          userSelect: isPressed || isResizing ? 'none' : 'auto'\n        });\n\n        return cloneElement(child, {\n          onMouseDown: onMouseDown,\n          onTouchStart: onTouchStart,\n          onResizeStart: onResizeStart,\n          onResizeStop: onResizeStop,\n          onResize: onResize,\n          onSizeChange: onSizeChange,\n          style: style\n        });\n      });\n    });\n  };\n\n  SortablePane.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        style = _a.style,\n        className = _a.className;\n    return createElement(\"div\", {\n      ref: function (c) {\n        if (c) {\n          _this.panesWrapper = c;\n        }\n      },\n      className: className,\n      style: __assign({\n        position: 'relative',\n        height: '100%'\n      }, style)\n    }, this.renderPanes());\n  };\n\n  SortablePane.defaultProps = {\n    direction: 'horizontal',\n    style: {},\n    children: [],\n    margin: 0,\n    onClick: function () {\n      return null;\n    },\n    onTouchStart: function () {\n      return null;\n    },\n    onResizeStart: function () {\n      return null;\n    },\n    onResize: function () {\n      return null;\n    },\n    onResizeStop: function () {\n      return null;\n    },\n    onDragStart: function () {\n      return null;\n    },\n    onDragStop: function () {\n      return null;\n    },\n    onOrderChange: function () {\n      return null;\n    },\n    className: '',\n    disableEffect: false,\n    isSortable: true,\n    springConfig: defaultSpringConfig\n  };\n  return SortablePane;\n}(Component);\n\nexport { Pane, SortablePane };","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["import { createElement, cloneElement, Component } from 'react';\nimport Resizable from 're-resizable';\nimport isEqual from 'lodash.isequal';\nimport { Motion, spring } from 'react-motion';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport debounce from 'lodash.debounce';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n};\n\nvar Pane = /** @class */ (function (_super) {\r\n    __extends(Pane, _super);\r\n    function Pane() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Pane.prototype.componentDidUpdate = function (prevProps) {\r\n        if (isEqual(prevProps.size, this.props.size))\r\n            return;\r\n        if (!this.props.onSizeChange)\r\n            return;\r\n        this.props.onSizeChange();\r\n    };\r\n    Object.defineProperty(Pane.prototype, \"createAllowedProps\", {\r\n        get: function () {\r\n            var _this = this;\r\n            var props = {};\r\n            return Object.keys(this.props).reduce(function (acc, key) {\r\n                if (['resizable', 'onSizeChange'].indexOf(key) !== -1)\r\n                    return acc;\r\n                acc[key] = _this.props[key];\r\n                return acc;\r\n            }, props);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Pane.prototype.render = function () {\r\n        return (createElement(Resizable, __assign({ enable: {\r\n                top: false,\r\n                right: this.props.resizable && this.props.resizable.x,\r\n                bottom: this.props.resizable && this.props.resizable.y,\r\n                left: false,\r\n                topRight: false,\r\n                bottomRight: this.props.resizable && this.props.resizable.xy,\r\n                bottomLeft: false,\r\n                topLeft: false,\r\n            } }, this.createAllowedProps), this.props.children));\r\n    };\r\n    Pane.defaultProps = {\r\n        minWidth: 0,\r\n        minHeight: 0,\r\n        maxWidth: undefined,\r\n        maxHeight: undefined,\r\n        style: {},\r\n        className: '',\r\n        grid: [1, 1],\r\n        resizable: {\r\n            x: true,\r\n            y: true,\r\n            xy: true,\r\n        },\r\n    };\r\n    return Pane;\r\n}(Component));\n\nvar MAXIMUM_Z_INDEX = 2147483647;\r\nvar HYSTERESIS = 10;\r\nfunction reinsert(array, from, to) {\r\n    var a = array.slice(0);\r\n    var v = a[from];\r\n    a.splice(from, 1);\r\n    a.splice(to, 0, v);\r\n    return a;\r\n}\r\nvar directionDict = {\r\n    right: 'x',\r\n    bottom: 'y',\r\n    bottomRight: 'xy',\r\n};\r\nvar clamp = function (n, min, max) {\r\n    if (min === void 0) { min = n; }\r\n    if (max === void 0) { max = n; }\r\n    return Math.max(Math.min(n, max), min);\r\n};\r\nvar defaultSpringConfig = {\r\n    damping: 30,\r\n    stiffness: 500,\r\n};\r\nvar SortablePane = /** @class */ (function (_super) {\r\n    __extends(SortablePane, _super);\r\n    function SortablePane(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        /**\r\n         * Find the position sum of halfway points of panes surrounding a given pane\r\n         *\r\n         *  |-------------|\r\n         *  |             | ---> 'previous' halfway\r\n         *  |-------------|\r\n         *                  <--- margin\r\n         *  |-------------|\r\n         *  | currentPane |\r\n         *  |-------------|\r\n         *                  <--- margin\r\n         *  |-------------|\r\n         *  |             |\r\n         *  |             | ---> 'next' halfway\r\n         *  |             |\r\n         *  |-------------|\r\n         *\r\n         *\r\n         * @param  {number}   currentPane - Index of reference pane\r\n         * @param  {number[]} sizes       - Array of pane sizes\r\n         * @param  {number}   margin      - The margin between panes\r\n         * @return {object}               - Object containing 'previous' and 'next'\r\n         *                                  pane halfway points\r\n         */\r\n        _this.getSurroundingHalfSizes = function (currentPane, sizes, margin) {\r\n            var nextPane = currentPane + 1;\r\n            var prevPane = currentPane - 1;\r\n            return sizes.reduce(function (sums, size, index) {\r\n                var newSums = { previous: 0, next: 0 };\r\n                if (index < prevPane) {\r\n                    newSums.previous = sums.previous + size + margin;\r\n                }\r\n                else if (index === prevPane) {\r\n                    newSums.previous = sums.previous + size / 2;\r\n                }\r\n                else {\r\n                    newSums.previous = sums.previous;\r\n                }\r\n                if (index < nextPane) {\r\n                    newSums.next = sums.next + size + margin;\r\n                }\r\n                else if (index === nextPane) {\r\n                    newSums.next = sums.next + size / 2;\r\n                }\r\n                else {\r\n                    newSums.next = sums.next;\r\n                }\r\n                return newSums;\r\n            }, { previous: 0, next: 0 });\r\n        };\r\n        var order = props.order || props.defaultOrder;\r\n        var children = props.children || [];\r\n        _this.state = {\r\n            delta: 0,\r\n            mouse: 0,\r\n            isPressed: false,\r\n            lastPressed: 0,\r\n            isResizing: false,\r\n            panes: order\r\n                ? order.map(function (key) {\r\n                    var c = children.find(function (c) { return c.key === key; });\r\n                    if (typeof c === 'undefined') {\r\n                        throw new Error(\"key [\" + key + \"] is not found in props.children. Please set correct key name to Pane component.\");\r\n                    }\r\n                    return {\r\n                        key: c.key,\r\n                        ref: null,\r\n                    };\r\n                })\r\n                : children.map(function (child) { return ({\r\n                    key: child.key,\r\n                    ref: null,\r\n                }); }),\r\n        };\r\n        _this.sizePropsUpdated = false;\r\n        _this.handleTouchMove = _this.handleTouchMove.bind(_this);\r\n        _this.handleMouseUp = _this.handleMouseUp.bind(_this);\r\n        _this.handleMove = _this.handleMove.bind(_this);\r\n        _this.debounceUpdate = debounce(function () { return _this.forceUpdate(); }, 100);\r\n        return _this;\r\n    }\r\n    SortablePane.prototype.componentDidMount = function () {\r\n        var _this = this;\r\n        if (typeof window !== 'undefined' && this.panesWrapper) {\r\n            var panesWrapper = this.panesWrapper;\r\n            panesWrapper.addEventListener('touchmove', this.handleTouchMove);\r\n            panesWrapper.addEventListener('touchend', this.handleMouseUp);\r\n            panesWrapper.addEventListener('mousemove', this.handleMove);\r\n            panesWrapper.addEventListener('mouseup', this.handleMouseUp);\r\n            panesWrapper.addEventListener('mouseleave', this.handleMouseUp);\r\n            this.resizeObserver = new ResizeObserver(this.debounceUpdate);\r\n        }\r\n        if (this.panesWrapper && this.panesWrapper.parentElement instanceof Element) {\r\n            this.resizeObserver.observe(this.panesWrapper);\r\n        }\r\n        if (!this.panesWrapper || !this.panesWrapper.children)\r\n            return;\r\n        var panes = [].slice.apply(this.panesWrapper.children) || [];\r\n        var newPanes = this.panes.map(function (pane, i) {\r\n            return {\r\n                key: pane.key,\r\n                ref: panes[_this.order[i]],\r\n            };\r\n        });\r\n        this.setState({ panes: newPanes });\r\n    };\r\n    SortablePane.prototype.componentDidUpdate = function (prevProps) {\r\n        var _this = this;\r\n        var panes = this.state.panes;\r\n        var children = this.props.children || [];\r\n        if (children.length > panes.length)\r\n            return this.addPane();\r\n        if (children.length < panes.length)\r\n            return this.removePane();\r\n        if (!isEqual(prevProps.order, this.props.order)) {\r\n            if (!this.panesWrapper)\r\n                return;\r\n            var newPanes = (this.props.order || []).map(function (key) {\r\n                var index = [].slice.apply(_this.props.children).findIndex(function (c) {\r\n                    return c.key === key;\r\n                });\r\n                return {\r\n                    ref: _this.panesWrapper.children[index],\r\n                    key: key,\r\n                };\r\n            });\r\n            this.setState({ panes: newPanes });\r\n        }\r\n        return undefined;\r\n    };\r\n    SortablePane.prototype.componentWillUnmount = function () {\r\n        if (typeof window !== 'undefined' && this.panesWrapper) {\r\n            var panesWrapper = this.panesWrapper;\r\n            panesWrapper.removeEventListener('touchmove', this.handleTouchMove);\r\n            panesWrapper.removeEventListener('touchend', this.handleMouseUp);\r\n            panesWrapper.removeEventListener('mousemove', this.handleMove);\r\n            panesWrapper.removeEventListener('mouseup', this.handleMouseUp);\r\n            if (this.panesWrapper && this.panesWrapper.parentElement instanceof Element) {\r\n                this.resizeObserver.unobserve(this.panesWrapper);\r\n            }\r\n        }\r\n    };\r\n    Object.defineProperty(SortablePane.prototype, \"order\", {\r\n        get: function () {\r\n            var children = this.props.children || [];\r\n            if (this.props.order) {\r\n                return this.props.order.map(function (key) {\r\n                    return children.findIndex(function (c) {\r\n                        return key === c.key;\r\n                    });\r\n                });\r\n            }\r\n            return this.panes.map(function (p) {\r\n                return children.findIndex(function (c) {\r\n                    return p.key === c.key;\r\n                });\r\n            });\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SortablePane.prototype, \"panes\", {\r\n        get: function () {\r\n            return this.state.panes.filter(function (p) { return !!p; });\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    SortablePane.prototype.onResize = function (i, e, dir, elementRef, delta) {\r\n        var panes = this.state.panes;\r\n        this.forceUpdate();\r\n        var pane = panes[this.order.indexOf(i)];\r\n        if (!pane)\r\n            return;\r\n        if (!this.props.onResize)\r\n            return;\r\n        var direction;\r\n        if (dir === 'right' || dir === 'bottom' || dir === 'bottomRight') {\r\n            direction = directionDict[dir];\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n        this.props.onResize(e, pane.key, direction, elementRef, delta);\r\n    };\r\n    SortablePane.prototype.getPaneSizeList = function () {\r\n        var width = this.panes.map(function (pane) {\r\n            return Number((pane.ref && pane.ref.offsetWidth) || 0);\r\n        });\r\n        var height = this.panes.map(function (pane) {\r\n            return Number((pane.ref && pane.ref.offsetHeight) || 0);\r\n        });\r\n        return this.isHorizontal() ? width : height;\r\n    };\r\n    /**\r\n     * Determine where a particular pane should be ordered\r\n     *\r\n     * @param  {number} position     - Top of the current pane\r\n     * @param  {number} paneIndex    - Index of the pane\r\n     * @return {number}              - New index of the pane based on position\r\n     */\r\n    SortablePane.prototype.getItemCountByPosition = function (position, paneIndex) {\r\n        var size = this.getPaneSizeList();\r\n        var margin = this.props.margin;\r\n        var halfSizes = this.getSurroundingHalfSizes(paneIndex, size, margin || 0);\r\n        if (position + size[paneIndex] > halfSizes.next + HYSTERESIS)\r\n            return paneIndex + 1;\r\n        if (position < halfSizes.previous - HYSTERESIS)\r\n            return paneIndex - 1;\r\n        return paneIndex;\r\n    };\r\n    SortablePane.prototype.getItemPositionByIndex = function (index) {\r\n        var size = this.getPaneSizeList();\r\n        var sum = 0;\r\n        if (size.some(function (s) { return typeof s === 'string'; }))\r\n            return 0;\r\n        for (var i = 0; i < index; i += 1) {\r\n            sum += size[i] + (this.props.margin || 0);\r\n        }\r\n        return sum;\r\n    };\r\n    SortablePane.prototype.isHorizontal = function () {\r\n        return this.props.direction === 'horizontal';\r\n    };\r\n    SortablePane.prototype.addPane = function () {\r\n        var _this = this;\r\n        if (!this.panesWrapper || !this.panesWrapper.children)\r\n            return;\r\n        var newPanes = this.panes;\r\n        var children = this.props.children || [];\r\n        children.forEach(function (child, i) {\r\n            var keys = _this.panes.map(function (pane) { return pane.key; });\r\n            if (keys.indexOf(child.key) === -1) {\r\n                var key = child.key;\r\n                var panesWrapper = _this.panesWrapper;\r\n                var pane = { key: key, ref: panesWrapper.children[i] };\r\n                newPanes.splice(i, 0, pane);\r\n            }\r\n        });\r\n        this.setState({ panes: newPanes });\r\n    };\r\n    SortablePane.prototype.removePane = function () {\r\n        var _this = this;\r\n        var newPanes = this.panes;\r\n        this.panes.forEach(function (pane, i) {\r\n            var keys = (_this.props.children || []).map(function (child) { return child.key; });\r\n            if (keys.indexOf(pane.key) === -1) {\r\n                newPanes.splice(i, 1);\r\n            }\r\n        });\r\n        this.setState({ panes: newPanes });\r\n    };\r\n    SortablePane.prototype.handleResizeStart = function (i, e, dir) {\r\n        var panes = this.state.panes;\r\n        this.setState({ isResizing: true });\r\n        var key = panes[this.order.indexOf(i)].key;\r\n        if (typeof key === 'undefined')\r\n            return;\r\n        if (this.props.onResizeStart) {\r\n            var direction = void 0;\r\n            if (dir === 'right' || dir === 'bottom' || dir === 'bottomRight') {\r\n                direction = directionDict[dir];\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n            this.props.onResizeStart(e, key, direction);\r\n        }\r\n    };\r\n    SortablePane.prototype.handleResizeStop = function (i, e, dir, elementRef, delta) {\r\n        var panes = this.state.panes;\r\n        this.setState({ isResizing: false });\r\n        var pane = panes[this.order.indexOf(i)];\r\n        var key = pane.key;\r\n        if (typeof key === 'undefined')\r\n            return;\r\n        if (this.props.onResizeStop) {\r\n            var direction = void 0;\r\n            if (dir === 'right' || dir === 'bottom' || dir === 'bottomRight') {\r\n                direction = directionDict[dir];\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n            this.props.onResizeStop(e, key, direction, elementRef, delta);\r\n        }\r\n    };\r\n    SortablePane.prototype.handleMouseDown = function (pos, pressX, pressY, e) {\r\n        if (this.props.dragHandleClassName) {\r\n            if (e.target instanceof HTMLElement) {\r\n                if (!e.target.classList.contains(this.props.dragHandleClassName)) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        var delta = 0;\r\n        if (window && window.TouchEvent && e.nativeEvent instanceof TouchEvent) {\r\n            var event_1 = e.nativeEvent.touches[0];\r\n            delta = this.isHorizontal() ? event_1.pageX - pressX : event_1.pageY - pressY;\r\n        }\r\n        else if (MouseEvent && e.nativeEvent instanceof MouseEvent) {\r\n            var event_2 = e.nativeEvent;\r\n            delta = this.isHorizontal() ? event_2.pageX - pressX : event_2.pageY - pressY;\r\n        }\r\n        this.setState({\r\n            delta: delta,\r\n            mouse: this.isHorizontal() ? pressX : pressY,\r\n            isPressed: true,\r\n            lastPressed: pos,\r\n        });\r\n        if (!this.props.children)\r\n            return;\r\n        var child = this.props.children[pos];\r\n        if (!child)\r\n            return;\r\n        if (child.props.onMouseDown)\r\n            child.props.onMouseDown(e);\r\n        if (this.props.onDragStart) {\r\n            var c = this.panes.find(function (p) { return p.key === child.key; });\r\n            if (c && c.ref) {\r\n                this.props.onDragStart(e, child.key, c.ref);\r\n            }\r\n        }\r\n    };\r\n    SortablePane.prototype.handleMove = function (_a) {\r\n        var pageX = _a.pageX, pageY = _a.pageY;\r\n        var _b = this.state, isPressed = _b.isPressed, delta = _b.delta, lastPressed = _b.lastPressed, isResizing = _b.isResizing, panes = _b.panes;\r\n        if (isPressed && !isResizing) {\r\n            var mouse = this.isHorizontal() ? pageX - delta : pageY - delta;\r\n            var length_1 = (this.props.children || []).length;\r\n            var newPosition = this.getItemCountByPosition(mouse, this.order.indexOf(lastPressed));\r\n            var pos = clamp(Math.round(newPosition), 0, length_1 - 1);\r\n            var newPanes = reinsert(panes, this.order.indexOf(lastPressed), pos);\r\n            this.setState({ mouse: mouse, panes: newPanes });\r\n            if (!this.props.onOrderChange)\r\n                return;\r\n            if (!isEqual(panes, newPanes)) {\r\n                if (this.props.onOrderChange) {\r\n                    this.props.onOrderChange(newPanes.map(function (p) { return String(p.key); }));\r\n                }\r\n            }\r\n        }\r\n    };\r\n    SortablePane.prototype.handleTouchStart = function (key, x, y, e, child) {\r\n        if (child.props.onTouchStart)\r\n            child.props.onTouchStart(e);\r\n        this.handleMouseDown(key, x, y, e);\r\n    };\r\n    SortablePane.prototype.handleTouchMove = function (e) {\r\n        e.preventDefault();\r\n        this.handleMove(e.touches[0]);\r\n    };\r\n    SortablePane.prototype.handleMouseUp = function (e) {\r\n        var children = this.props.children || [];\r\n        if (children.length === 0)\r\n            return;\r\n        var wasPressed = this.state.isPressed;\r\n        this.setState({ isPressed: false, delta: 0 });\r\n        var child = children[this.state.lastPressed];\r\n        var lastPressedId = child.key;\r\n        if (!this.props.isSortable)\r\n            return;\r\n        var panes = this.state.panes;\r\n        if (this.props.onDragStop && wasPressed) {\r\n            var c = this.panes.find(function (p) { return p.key === child.key; });\r\n            if (c && c.ref) {\r\n                this.props.onDragStop(e, child.key, c.ref, panes.map(function (p) { return String(p.key); }));\r\n            }\r\n        }\r\n    };\r\n    SortablePane.prototype.renderPanes = function () {\r\n        var _this = this;\r\n        var _a = this.state, mouse = _a.mouse, isPressed = _a.isPressed, lastPressed = _a.lastPressed, isResizing = _a.isResizing;\r\n        var _b = this.props, disableEffect = _b.disableEffect, isSortable = _b.isSortable, springConfig = _b.springConfig;\r\n        var children = this.props.children || [];\r\n        return children.map(function (child, i) {\r\n            var pos = _this.props.order\r\n                ? _this.getItemPositionByIndex(_this.props.order.indexOf(String(child.key)))\r\n                : _this.getItemPositionByIndex(_this.order.indexOf(i));\r\n            var springPosition = spring(pos, springConfig);\r\n            var style = lastPressed === i && isPressed && !isResizing\r\n                ? {\r\n                    scale: disableEffect ? 1 : spring(1.05, springConfig),\r\n                    shadow: disableEffect ? 0 : spring(16, springConfig),\r\n                    x: _this.isHorizontal() ? mouse : 0,\r\n                    y: !_this.isHorizontal() ? mouse : 0,\r\n                }\r\n                : {\r\n                    scale: disableEffect ? 1 : spring(1, springConfig),\r\n                    shadow: disableEffect ? 0 : spring(0, springConfig),\r\n                    x: _this.isHorizontal() ? springPosition : 0,\r\n                    y: !_this.isHorizontal() ? springPosition : 0,\r\n                };\r\n            return (createElement(Motion, { style: style, key: String(child.key) }, function (_a) {\r\n                var scale = _a.scale, shadow = _a.shadow, x = _a.x, y = _a.y;\r\n                var onResize = _this.onResize.bind(_this, i);\r\n                var onMouseDown = isSortable\r\n                    ? _this.handleMouseDown.bind(_this, i, x, y)\r\n                    : function (e) {\r\n                        if (child.props.onMouseDown)\r\n                            child.props.onMouseDown(e);\r\n                    };\r\n                var onTouchStart = _this.handleTouchStart.bind(_this, i, x, y, child);\r\n                var onResizeStart = _this.handleResizeStart.bind(_this, i);\r\n                var onResizeStop = _this.handleResizeStop.bind(_this, i);\r\n                var onSizeChange = function () { return _this.forceUpdate(); };\r\n                var style = __assign({}, child.props.style, { boxShadow: \"rgba(0, 0, 0, 0.2) 0px \" + shadow + \"px \" + 2 * shadow + \"px 0px\", transform: \"translate3d(\" + x + \"px, \" + y + \"px, 0px) scale(\" + scale + \")\", WebkitTransform: \"translate3d(\" + x + \"px, \" + y + \"px, 0px) scale(\" + scale + \")\", MozTransform: \"translate3d(\" + x + \"px, \" + y + \"px, 0px) scale(\" + scale + \")\", MsTransform: \"translate3d(\" + x + \"px, \" + y + \"px, 0px) scale(\" + scale + \")\", zIndex: (i === lastPressed && _this.state.isPressed\r\n                        ? MAXIMUM_Z_INDEX\r\n                        : (child.props.style && child.props.style.zIndex) || 'auto'), position: 'absolute', userSelect: isPressed || isResizing ? 'none' : 'auto' });\r\n                return cloneElement(child, {\r\n                    onMouseDown: onMouseDown,\r\n                    onTouchStart: onTouchStart,\r\n                    onResizeStart: onResizeStart,\r\n                    onResizeStop: onResizeStop,\r\n                    onResize: onResize,\r\n                    onSizeChange: onSizeChange,\r\n                    style: style,\r\n                });\r\n            }));\r\n        });\r\n    };\r\n    SortablePane.prototype.render = function () {\r\n        var _this = this;\r\n        var _a = this.props, style = _a.style, className = _a.className;\r\n        return (createElement(\"div\", { ref: function (c) {\r\n                if (c) {\r\n                    _this.panesWrapper = c;\r\n                }\r\n            }, className: className, style: __assign({ position: 'relative', height: '100%' }, style) }, this.renderPanes()));\r\n    };\r\n    SortablePane.defaultProps = {\r\n        direction: 'horizontal',\r\n        style: {},\r\n        children: [],\r\n        margin: 0,\r\n        onClick: function () { return null; },\r\n        onTouchStart: function () { return null; },\r\n        onResizeStart: function () { return null; },\r\n        onResize: function () { return null; },\r\n        onResizeStop: function () { return null; },\r\n        onDragStart: function () { return null; },\r\n        onDragStop: function () { return null; },\r\n        onOrderChange: function () { return null; },\r\n        className: '',\r\n        disableEffect: false,\r\n        isSortable: true,\r\n        springConfig: defaultSpringConfig\r\n    };\r\n    return SortablePane;\r\n}(Component));\n\nexport { Pane, SortablePane };\n"]},"metadata":{},"sourceType":"module"}