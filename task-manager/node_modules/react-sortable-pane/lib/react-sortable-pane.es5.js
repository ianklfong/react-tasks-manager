'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var Resizable = _interopDefault(require('re-resizable'));
var isEqual = _interopDefault(require('lodash.isequal'));
var reactMotion = require('react-motion');
var ResizeObserver = _interopDefault(require('resize-observer-polyfill'));
var debounce = _interopDefault(require('lodash.debounce'));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

var Pane = /** @class */ (function (_super) {
    __extends(Pane, _super);
    function Pane() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Pane.prototype.componentDidUpdate = function (prevProps) {
        if (isEqual(prevProps.size, this.props.size))
            return;
        if (!this.props.onSizeChange)
            return;
        this.props.onSizeChange();
    };
    Object.defineProperty(Pane.prototype, "createAllowedProps", {
        get: function () {
            var _this = this;
            var props = {};
            return Object.keys(this.props).reduce(function (acc, key) {
                if (['resizable', 'onSizeChange'].indexOf(key) !== -1)
                    return acc;
                acc[key] = _this.props[key];
                return acc;
            }, props);
        },
        enumerable: true,
        configurable: true
    });
    Pane.prototype.render = function () {
        return (React.createElement(Resizable, __assign({ enable: {
                top: false,
                right: this.props.resizable && this.props.resizable.x,
                bottom: this.props.resizable && this.props.resizable.y,
                left: false,
                topRight: false,
                bottomRight: this.props.resizable && this.props.resizable.xy,
                bottomLeft: false,
                topLeft: false,
            } }, this.createAllowedProps), this.props.children));
    };
    Pane.defaultProps = {
        minWidth: 0,
        minHeight: 0,
        maxWidth: undefined,
        maxHeight: undefined,
        style: {},
        className: '',
        grid: [1, 1],
        resizable: {
            x: true,
            y: true,
            xy: true,
        },
    };
    return Pane;
}(React.Component));

var MAXIMUM_Z_INDEX = 2147483647;
var HYSTERESIS = 10;
function reinsert(array, from, to) {
    var a = array.slice(0);
    var v = a[from];
    a.splice(from, 1);
    a.splice(to, 0, v);
    return a;
}
var directionDict = {
    right: 'x',
    bottom: 'y',
    bottomRight: 'xy',
};
var clamp = function (n, min, max) {
    if (min === void 0) { min = n; }
    if (max === void 0) { max = n; }
    return Math.max(Math.min(n, max), min);
};
var defaultSpringConfig = {
    damping: 30,
    stiffness: 500,
};
var SortablePane = /** @class */ (function (_super) {
    __extends(SortablePane, _super);
    function SortablePane(props) {
        var _this = _super.call(this, props) || this;
        /**
         * Find the position sum of halfway points of panes surrounding a given pane
         *
         *  |-------------|
         *  |             | ---> 'previous' halfway
         *  |-------------|
         *                  <--- margin
         *  |-------------|
         *  | currentPane |
         *  |-------------|
         *                  <--- margin
         *  |-------------|
         *  |             |
         *  |             | ---> 'next' halfway
         *  |             |
         *  |-------------|
         *
         *
         * @param  {number}   currentPane - Index of reference pane
         * @param  {number[]} sizes       - Array of pane sizes
         * @param  {number}   margin      - The margin between panes
         * @return {object}               - Object containing 'previous' and 'next'
         *                                  pane halfway points
         */
        _this.getSurroundingHalfSizes = function (currentPane, sizes, margin) {
            var nextPane = currentPane + 1;
            var prevPane = currentPane - 1;
            return sizes.reduce(function (sums, size, index) {
                var newSums = { previous: 0, next: 0 };
                if (index < prevPane) {
                    newSums.previous = sums.previous + size + margin;
                }
                else if (index === prevPane) {
                    newSums.previous = sums.previous + size / 2;
                }
                else {
                    newSums.previous = sums.previous;
                }
                if (index < nextPane) {
                    newSums.next = sums.next + size + margin;
                }
                else if (index === nextPane) {
                    newSums.next = sums.next + size / 2;
                }
                else {
                    newSums.next = sums.next;
                }
                return newSums;
            }, { previous: 0, next: 0 });
        };
        var order = props.order || props.defaultOrder;
        var children = props.children || [];
        _this.state = {
            delta: 0,
            mouse: 0,
            isPressed: false,
            lastPressed: 0,
            isResizing: false,
            panes: order
                ? order.map(function (key) {
                    var c = children.find(function (c) { return c.key === key; });
                    if (typeof c === 'undefined') {
                        throw new Error("key [" + key + "] is not found in props.children. Please set correct key name to Pane component.");
                    }
                    return {
                        key: c.key,
                        ref: null,
                    };
                })
                : children.map(function (child) { return ({
                    key: child.key,
                    ref: null,
                }); }),
        };
        _this.sizePropsUpdated = false;
        _this.handleTouchMove = _this.handleTouchMove.bind(_this);
        _this.handleMouseUp = _this.handleMouseUp.bind(_this);
        _this.handleMove = _this.handleMove.bind(_this);
        _this.debounceUpdate = debounce(function () { return _this.forceUpdate(); }, 100);
        return _this;
    }
    SortablePane.prototype.componentDidMount = function () {
        var _this = this;
        if (typeof window !== 'undefined' && this.panesWrapper) {
            var panesWrapper = this.panesWrapper;
            panesWrapper.addEventListener('touchmove', this.handleTouchMove);
            panesWrapper.addEventListener('touchend', this.handleMouseUp);
            panesWrapper.addEventListener('mousemove', this.handleMove);
            panesWrapper.addEventListener('mouseup', this.handleMouseUp);
            panesWrapper.addEventListener('mouseleave', this.handleMouseUp);
            this.resizeObserver = new ResizeObserver(this.debounceUpdate);
        }
        if (this.panesWrapper && this.panesWrapper.parentElement instanceof Element) {
            this.resizeObserver.observe(this.panesWrapper);
        }
        if (!this.panesWrapper || !this.panesWrapper.children)
            return;
        var panes = [].slice.apply(this.panesWrapper.children) || [];
        var newPanes = this.panes.map(function (pane, i) {
            return {
                key: pane.key,
                ref: panes[_this.order[i]],
            };
        });
        this.setState({ panes: newPanes });
    };
    SortablePane.prototype.componentDidUpdate = function (prevProps) {
        var _this = this;
        var panes = this.state.panes;
        var children = this.props.children || [];
        if (children.length > panes.length)
            return this.addPane();
        if (children.length < panes.length)
            return this.removePane();
        if (!isEqual(prevProps.order, this.props.order)) {
            if (!this.panesWrapper)
                return;
            var newPanes = (this.props.order || []).map(function (key) {
                var index = [].slice.apply(_this.props.children).findIndex(function (c) {
                    return c.key === key;
                });
                return {
                    ref: _this.panesWrapper.children[index],
                    key: key,
                };
            });
            this.setState({ panes: newPanes });
        }
        return undefined;
    };
    SortablePane.prototype.componentWillUnmount = function () {
        if (typeof window !== 'undefined' && this.panesWrapper) {
            var panesWrapper = this.panesWrapper;
            panesWrapper.removeEventListener('touchmove', this.handleTouchMove);
            panesWrapper.removeEventListener('touchend', this.handleMouseUp);
            panesWrapper.removeEventListener('mousemove', this.handleMove);
            panesWrapper.removeEventListener('mouseup', this.handleMouseUp);
            if (this.panesWrapper && this.panesWrapper.parentElement instanceof Element) {
                this.resizeObserver.unobserve(this.panesWrapper);
            }
        }
    };
    Object.defineProperty(SortablePane.prototype, "order", {
        get: function () {
            var children = this.props.children || [];
            if (this.props.order) {
                return this.props.order.map(function (key) {
                    return children.findIndex(function (c) {
                        return key === c.key;
                    });
                });
            }
            return this.panes.map(function (p) {
                return children.findIndex(function (c) {
                    return p.key === c.key;
                });
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SortablePane.prototype, "panes", {
        get: function () {
            return this.state.panes.filter(function (p) { return !!p; });
        },
        enumerable: true,
        configurable: true
    });
    SortablePane.prototype.onResize = function (i, e, dir, elementRef, delta) {
        var panes = this.state.panes;
        this.forceUpdate();
        var pane = panes[this.order.indexOf(i)];
        if (!pane)
            return;
        if (!this.props.onResize)
            return;
        var direction;
        if (dir === 'right' || dir === 'bottom' || dir === 'bottomRight') {
            direction = directionDict[dir];
        }
        else {
            return;
        }
        this.props.onResize(e, pane.key, direction, elementRef, delta);
    };
    SortablePane.prototype.getPaneSizeList = function () {
        var width = this.panes.map(function (pane) {
            return Number((pane.ref && pane.ref.offsetWidth) || 0);
        });
        var height = this.panes.map(function (pane) {
            return Number((pane.ref && pane.ref.offsetHeight) || 0);
        });
        return this.isHorizontal() ? width : height;
    };
    /**
     * Determine where a particular pane should be ordered
     *
     * @param  {number} position     - Top of the current pane
     * @param  {number} paneIndex    - Index of the pane
     * @return {number}              - New index of the pane based on position
     */
    SortablePane.prototype.getItemCountByPosition = function (position, paneIndex) {
        var size = this.getPaneSizeList();
        var margin = this.props.margin;
        var halfSizes = this.getSurroundingHalfSizes(paneIndex, size, margin || 0);
        if (position + size[paneIndex] > halfSizes.next + HYSTERESIS)
            return paneIndex + 1;
        if (position < halfSizes.previous - HYSTERESIS)
            return paneIndex - 1;
        return paneIndex;
    };
    SortablePane.prototype.getItemPositionByIndex = function (index) {
        var size = this.getPaneSizeList();
        var sum = 0;
        if (size.some(function (s) { return typeof s === 'string'; }))
            return 0;
        for (var i = 0; i < index; i += 1) {
            sum += size[i] + (this.props.margin || 0);
        }
        return sum;
    };
    SortablePane.prototype.isHorizontal = function () {
        return this.props.direction === 'horizontal';
    };
    SortablePane.prototype.addPane = function () {
        var _this = this;
        if (!this.panesWrapper || !this.panesWrapper.children)
            return;
        var newPanes = this.panes;
        var children = this.props.children || [];
        children.forEach(function (child, i) {
            var keys = _this.panes.map(function (pane) { return pane.key; });
            if (keys.indexOf(child.key) === -1) {
                var key = child.key;
                var panesWrapper = _this.panesWrapper;
                var pane = { key: key, ref: panesWrapper.children[i] };
                newPanes.splice(i, 0, pane);
            }
        });
        this.setState({ panes: newPanes });
    };
    SortablePane.prototype.removePane = function () {
        var _this = this;
        var newPanes = this.panes;
        this.panes.forEach(function (pane, i) {
            var keys = (_this.props.children || []).map(function (child) { return child.key; });
            if (keys.indexOf(pane.key) === -1) {
                newPanes.splice(i, 1);
            }
        });
        this.setState({ panes: newPanes });
    };
    SortablePane.prototype.handleResizeStart = function (i, e, dir) {
        var panes = this.state.panes;
        this.setState({ isResizing: true });
        var key = panes[this.order.indexOf(i)].key;
        if (typeof key === 'undefined')
            return;
        if (this.props.onResizeStart) {
            var direction = void 0;
            if (dir === 'right' || dir === 'bottom' || dir === 'bottomRight') {
                direction = directionDict[dir];
            }
            else {
                return;
            }
            this.props.onResizeStart(e, key, direction);
        }
    };
    SortablePane.prototype.handleResizeStop = function (i, e, dir, elementRef, delta) {
        var panes = this.state.panes;
        this.setState({ isResizing: false });
        var pane = panes[this.order.indexOf(i)];
        var key = pane.key;
        if (typeof key === 'undefined')
            return;
        if (this.props.onResizeStop) {
            var direction = void 0;
            if (dir === 'right' || dir === 'bottom' || dir === 'bottomRight') {
                direction = directionDict[dir];
            }
            else {
                return;
            }
            this.props.onResizeStop(e, key, direction, elementRef, delta);
        }
    };
    SortablePane.prototype.handleMouseDown = function (pos, pressX, pressY, e) {
        if (this.props.dragHandleClassName) {
            if (e.target instanceof HTMLElement) {
                if (!e.target.classList.contains(this.props.dragHandleClassName)) {
                    return;
                }
            }
        }
        var delta = 0;
        if (window && window.TouchEvent && e.nativeEvent instanceof TouchEvent) {
            var event_1 = e.nativeEvent.touches[0];
            delta = this.isHorizontal() ? event_1.pageX - pressX : event_1.pageY - pressY;
        }
        else if (MouseEvent && e.nativeEvent instanceof MouseEvent) {
            var event_2 = e.nativeEvent;
            delta = this.isHorizontal() ? event_2.pageX - pressX : event_2.pageY - pressY;
        }
        this.setState({
            delta: delta,
            mouse: this.isHorizontal() ? pressX : pressY,
            isPressed: true,
            lastPressed: pos,
        });
        if (!this.props.children)
            return;
        var child = this.props.children[pos];
        if (!child)
            return;
        if (child.props.onMouseDown)
            child.props.onMouseDown(e);
        if (this.props.onDragStart) {
            var c = this.panes.find(function (p) { return p.key === child.key; });
            if (c && c.ref) {
                this.props.onDragStart(e, child.key, c.ref);
            }
        }
    };
    SortablePane.prototype.handleMove = function (_a) {
        var pageX = _a.pageX, pageY = _a.pageY;
        var _b = this.state, isPressed = _b.isPressed, delta = _b.delta, lastPressed = _b.lastPressed, isResizing = _b.isResizing, panes = _b.panes;
        if (isPressed && !isResizing) {
            var mouse = this.isHorizontal() ? pageX - delta : pageY - delta;
            var length_1 = (this.props.children || []).length;
            var newPosition = this.getItemCountByPosition(mouse, this.order.indexOf(lastPressed));
            var pos = clamp(Math.round(newPosition), 0, length_1 - 1);
            var newPanes = reinsert(panes, this.order.indexOf(lastPressed), pos);
            this.setState({ mouse: mouse, panes: newPanes });
            if (!this.props.onOrderChange)
                return;
            if (!isEqual(panes, newPanes)) {
                if (this.props.onOrderChange) {
                    this.props.onOrderChange(newPanes.map(function (p) { return String(p.key); }));
                }
            }
        }
    };
    SortablePane.prototype.handleTouchStart = function (key, x, y, e, child) {
        if (child.props.onTouchStart)
            child.props.onTouchStart(e);
        this.handleMouseDown(key, x, y, e);
    };
    SortablePane.prototype.handleTouchMove = function (e) {
        e.preventDefault();
        this.handleMove(e.touches[0]);
    };
    SortablePane.prototype.handleMouseUp = function (e) {
        var children = this.props.children || [];
        if (children.length === 0)
            return;
        var wasPressed = this.state.isPressed;
        this.setState({ isPressed: false, delta: 0 });
        var child = children[this.state.lastPressed];
        var lastPressedId = child.key;
        if (!this.props.isSortable)
            return;
        var panes = this.state.panes;
        if (this.props.onDragStop && wasPressed) {
            var c = this.panes.find(function (p) { return p.key === child.key; });
            if (c && c.ref) {
                this.props.onDragStop(e, child.key, c.ref, panes.map(function (p) { return String(p.key); }));
            }
        }
    };
    SortablePane.prototype.renderPanes = function () {
        var _this = this;
        var _a = this.state, mouse = _a.mouse, isPressed = _a.isPressed, lastPressed = _a.lastPressed, isResizing = _a.isResizing;
        var _b = this.props, disableEffect = _b.disableEffect, isSortable = _b.isSortable, springConfig = _b.springConfig;
        var children = this.props.children || [];
        return children.map(function (child, i) {
            var pos = _this.props.order
                ? _this.getItemPositionByIndex(_this.props.order.indexOf(String(child.key)))
                : _this.getItemPositionByIndex(_this.order.indexOf(i));
            var springPosition = reactMotion.spring(pos, springConfig);
            var style = lastPressed === i && isPressed && !isResizing
                ? {
                    scale: disableEffect ? 1 : reactMotion.spring(1.05, springConfig),
                    shadow: disableEffect ? 0 : reactMotion.spring(16, springConfig),
                    x: _this.isHorizontal() ? mouse : 0,
                    y: !_this.isHorizontal() ? mouse : 0,
                }
                : {
                    scale: disableEffect ? 1 : reactMotion.spring(1, springConfig),
                    shadow: disableEffect ? 0 : reactMotion.spring(0, springConfig),
                    x: _this.isHorizontal() ? springPosition : 0,
                    y: !_this.isHorizontal() ? springPosition : 0,
                };
            return (React.createElement(reactMotion.Motion, { style: style, key: String(child.key) }, function (_a) {
                var scale = _a.scale, shadow = _a.shadow, x = _a.x, y = _a.y;
                var onResize = _this.onResize.bind(_this, i);
                var onMouseDown = isSortable
                    ? _this.handleMouseDown.bind(_this, i, x, y)
                    : function (e) {
                        if (child.props.onMouseDown)
                            child.props.onMouseDown(e);
                    };
                var onTouchStart = _this.handleTouchStart.bind(_this, i, x, y, child);
                var onResizeStart = _this.handleResizeStart.bind(_this, i);
                var onResizeStop = _this.handleResizeStop.bind(_this, i);
                var onSizeChange = function () { return _this.forceUpdate(); };
                var style = __assign({}, child.props.style, { boxShadow: "rgba(0, 0, 0, 0.2) 0px " + shadow + "px " + 2 * shadow + "px 0px", transform: "translate3d(" + x + "px, " + y + "px, 0px) scale(" + scale + ")", WebkitTransform: "translate3d(" + x + "px, " + y + "px, 0px) scale(" + scale + ")", MozTransform: "translate3d(" + x + "px, " + y + "px, 0px) scale(" + scale + ")", MsTransform: "translate3d(" + x + "px, " + y + "px, 0px) scale(" + scale + ")", zIndex: (i === lastPressed && _this.state.isPressed
                        ? MAXIMUM_Z_INDEX
                        : (child.props.style && child.props.style.zIndex) || 'auto'), position: 'absolute', userSelect: isPressed || isResizing ? 'none' : 'auto' });
                return React.cloneElement(child, {
                    onMouseDown: onMouseDown,
                    onTouchStart: onTouchStart,
                    onResizeStart: onResizeStart,
                    onResizeStop: onResizeStop,
                    onResize: onResize,
                    onSizeChange: onSizeChange,
                    style: style,
                });
            }));
        });
    };
    SortablePane.prototype.render = function () {
        var _this = this;
        var _a = this.props, style = _a.style, className = _a.className;
        return (React.createElement("div", { ref: function (c) {
                if (c) {
                    _this.panesWrapper = c;
                }
            }, className: className, style: __assign({ position: 'relative', height: '100%' }, style) }, this.renderPanes()));
    };
    SortablePane.defaultProps = {
        direction: 'horizontal',
        style: {},
        children: [],
        margin: 0,
        onClick: function () { return null; },
        onTouchStart: function () { return null; },
        onResizeStart: function () { return null; },
        onResize: function () { return null; },
        onResizeStop: function () { return null; },
        onDragStart: function () { return null; },
        onDragStop: function () { return null; },
        onOrderChange: function () { return null; },
        className: '',
        disableEffect: false,
        isSortable: true,
        springConfig: defaultSpringConfig
    };
    return SortablePane;
}(React.Component));

exports.Pane = Pane;
exports.SortablePane = SortablePane;
//# sourceMappingURL=react-sortable-pane.es5.js.map
